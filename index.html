<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional WebGIS Platform</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIINfBG9z7sE3YtxzQ/lvigsaBVHaWdijFM=" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.css" />
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .sidebar { background-color: #343a40; color: white; padding: 20px; height: 100vh; overflow-y: auto; }
        .map-container { position: relative; height: 70vh; width: 100%; }
        #map { height: 100%; width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .attr-table-container { height: 30vh; overflow-y: auto; background-color: #f8f9fa; border-top: 1px solid #dee2e6; padding: 15px; }
        .layer-item { cursor: pointer; padding: 10px; border-bottom: 1px solid #495057; transition: background-color 0.2s; font-size: 0.9em; }
        .layer-item:hover { background-color: #495057; }
        .layer-item.active { background-color: #007bff; color: white; }
        .form-label { color: #ccc; }
        .btn-sm { font-size: 0.85em; padding: 0.4rem 0.8rem; }
        h4, h5 { color: #fff; border-bottom: 1px solid #495057; padding-bottom: 10px; margin-bottom: 15px; }
        .table-sm th, .table-sm td { font-size: 0.8em; }
        .table-striped tbody tr:nth-of-type(odd) { background-color: rgba(0, 123, 255, 0.05); }
    </style>
</head>
<body>
    <div class="container-fluid h-100">
        <div class="row h-100">
            <div class="col-md-3 sidebar">
                <h4 class="text-center mb-4">üåç WebGIS Pro</h4>
                
                <div class="card bg-dark text-white mb-4">
                    <div class="card-body">
                        <h5 class="card-title">‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</h5>
                        <label for="fileInput" class="form-label">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå (Zip/GeoJSON)</label>
                        <input type="file" id="fileInput" class="form-control form-control-sm bg-secondary text-white border-0">
                        <button onclick="handleUpload()" class="btn btn-success btn-sm mt-3 w-100">‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î</button>
                    </div>
                </div>

                <h5 class="mt-4">‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö</h5>
                <div id="layerList" class="mb-4">
                    </div>

                <div class="card bg-dark text-white mb-4">
                    <div class="card-body">
                        <h5 class="card-title">‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå Buffer</h5>
                        <label for="bufferLayerSelect" class="form-label">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</label>
                        <select id="bufferLayerSelect" class="form-select form-select-sm mb-2 bg-secondary text-white border-0"></select>
                        <label for="bufferDistance" class="form-label">‡∏£‡∏∞‡∏¢‡∏∞ Buffer (‡πÄ‡∏°‡∏ï‡∏£)</label>
                        <input type="number" id="bufferDistance" class="form-control form-control-sm mb-2 bg-secondary text-white border-0" value="100">
                        <button onclick="runBufferAnalysis()" class="btn btn-info btn-sm mt-2 w-100">‡∏£‡∏±‡∏ô Buffer</button>
                    </div>
                </div>

            </div>

            <div class="col-md-9 d-flex flex-column p-0">
                <div class="map-container">
                    <div id="map"></div>
                </div>
                <div class="attr-table-container">
                    <h6>‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Attribute Table)</h6>
                    <div class="table-responsive">
                        <table class="table table-sm table-striped table-hover" id="attributeTable">
                            <thead></thead>
                            <tbody></tbody>
                        </table>
                        <div id="noDataMessage" class="text-center text-muted mt-3" style="display: none;">
                            ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eE+R7eXpA1Za/H6L7M6K1" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjGwclwX/cfZgFDgkAoWKihkmyCAg0=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.js"></script>

    <script>
        const API_BASE_URL = window.location.origin; // Use current host for API calls

        // --- Map Initialization ---
        const map = L.map('map').setView([13.75, 100.5], 6);

        // Base Maps
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' });
        const dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CartoDB' });
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' });
        
        // Default base map
        osm.addTo(map);

        const baseMaps = {
            "OpenStreetMap": osm,
            "Dark Mode": dark,
            "Esri Satellite": satellite
        };
        L.control.layers(baseMaps).addTo(map);

        // Geocoder Control
        L.Control.geocoder({
            defaultMarkGeocode: false,
            placeholder: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà...",
            errorMessage: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà"
        }).on('geocode:result', function(e) {
            const bbox = e.result.bbox;
            const poly = L.polygon([
                [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
                [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
                [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
                [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
            ]).addTo(map);
            map.fitBounds(poly.getBounds());
        }).addTo(map);

        let activeGeojsonLayer = null;
        let activeTableName = null;

        // --- API Functions ---
        async function fetchAPI(endpoint, method = 'GET', body = null, headers = {}) {
            const options = { method, headers };
            if (body) {
                options.body = body instanceof FormData ? body : JSON.stringify(body);
                if (!(body instanceof FormData)) {
                    options.headers = { ...options.headers, 'Content-Type': 'application/json' };
                }
            }
            const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || response.statusText);
            }
            return response.json();
        }

        // --- Layer Management ---
        async function refreshLayerList() {
            try {
                const layers = await fetchAPI('/api/layers');
                const layerListDiv = document.getElementById('layerList');
                const bufferLayerSelect = document.getElementById('bufferLayerSelect');
                layerListDiv.innerHTML = '';
                bufferLayerSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• --</option>';

                layers.forEach(layer => {
                    // Layer Item for Display
                    const layerItem = document.createElement('div');
                    layerItem.className = 'layer-item';
                    layerItem.innerHTML = `<span class="fw-bold">${layer.name}</span> <small>(${layer.geom_type})</small>
                                            <button class="btn btn-outline-light btn-sm float-end ms-2" title="Export" onclick="event.stopPropagation(); exportLayer('${layer.name}')">
                                                <i class="fas fa-download"></i> Export
                                            </button>
                                          `;
                    layerItem.onclick = () => loadLayerGeoJSON(layer.name);
                    layerListDiv.appendChild(layerItem);

                    // Option for Buffer Analysis
                    const option = document.createElement('option');
                    option.value = layer.name;
                    option.innerText = layer.name;
                    bufferLayerSelect.appendChild(option);
                });
            } catch (error) {
                alert(`Error loading layers: ${error.message}`);
            }
        }

        async function loadLayerGeoJSON(tableName) {
            try {
                // Remove active class from previous layer
                const activeItem = document.querySelector('.layer-item.active');
                if (activeItem) activeItem.classList.remove('active');

                // Add active class to current layer
                event.target.closest('.layer-item').classList.add('active');


                const geojson = await fetchAPI(`/api/layers/${tableName}/geojson`);
                if (activeGeojsonLayer) {
                    map.removeLayer(activeGeojsonLayer);
                }
                activeGeojsonLayer = L.geoJSON(geojson, {
                    onEachFeature: function (feature, layer) {
                        if (feature.properties) {
                            let popupContent = "<table>";
                            for (const key in feature.properties) {
                                popupContent += `<tr><th>${key}:</th><td>${feature.properties[key]}</td></tr>`;
                            }
                            popupContent += "</table>";
                            layer.bindPopup(popupContent);
                        }
                    }
                }).addTo(map);
                map.fitBounds(activeGeojsonLayer.getBounds());
                activeTableName = tableName; // Set active table for attribute display
                loadAttributeTable(tableName);
            } catch (error) {
                alert(`Error loading GeoJSON: ${error.message}`);
            }
        }

        async function loadAttributeTable(tableName) {
            const tableHead = document.querySelector('#attributeTable thead');
            const tableBody = document.querySelector('#attributeTable tbody');
            const noDataMessage = document.getElementById('noDataMessage');

            try {
                const data = await fetchAPI(`/api/layers/${tableName}/attributes`);
                if (data.data.length === 0) {
                    tableHead.innerHTML = '<tr><th>‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</th></tr>';
                    tableBody.innerHTML = '';
                    noDataMessage.style.display = 'block';
                    return;
                }

                noDataMessage.style.display = 'none';
                tableHead.innerHTML = `<tr>${data.headers.map(h => `<th>${h}</th>`).join('')}</tr>`;
                tableBody.innerHTML = data.data.map(row => `
                    <tr>${data.headers.map(h => `<td>${row[h]}</td>`).join('')}</tr>
                `).join('');
            } catch (error) {
                console.error("Error loading attributes:", error);
                tableHead.innerHTML = '<tr><th>‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</th></tr>';
                tableBody.innerHTML = '';
                noDataMessage.style.display = 'block';
            }
        }

        // --- File Operations ---
        async function handleUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Å‡πà‡∏≠‡∏ô‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                const result = await fetchAPI('/api/upload', 'POST', formData);
                alert(result.message);
                fileInput.value = ''; // Clear file input
                refreshLayerList();
            } catch (error) {
                alert(`Upload failed: ${error.message}`);
            }
        }

        async function exportLayer(tableName) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/export/${tableName}/shapefile`);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || response.statusText);
                }
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `${tableName}_export.zip`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                alert(`Layer '${tableName}' ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô Shapefile ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!`);
            } catch (error) {
                alert(`Export failed: ${error.message}`);
            }
        }

        // --- Spatial Analysis ---
        async function runBufferAnalysis() {
            const table = document.getElementById('bufferLayerSelect').value;
            const distance = parseFloat(document.getElementById('bufferDistance').value);

            if (!table || isNaN(distance) || distance <= 0) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏ö‡∏∏‡∏£‡∏∞‡∏¢‡∏∞ Buffer ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0)');
                return;
            }

            try {
                const result = await fetchAPI('/api/analysis/buffer', 'POST', { table_name: table, distance: distance });
                alert(result.message);
                refreshLayerList(); // Refresh to show new buffer layer
            } catch (error) {
                alert(`Buffer analysis failed: ${error.message}`);
            }
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            refreshLayerList();
            // Load Font Awesome for icons (Export button)
            const faScript = document.createElement('script');
            faScript.src = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js";
            faScript.crossOrigin = "anonymous";
            faScript.referrerPolicy = "no-referrer";
            document.head.appendChild(faScript);
        });
    </script>
</body>
</html>